<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="瞎bb的私密小天地，羞"><title>使用rust写一个基于QUIC的proxy[0] | 做正确的事</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=Lato"></head><body><!-- gallery that comes before the header--><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a href="/" class="sidebar-nav-item active">Home</a><a href="/archives" class="sidebar-nav-item">Archives</a><a href="/about" class="sidebar-nav-item">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/hyper/">hyper</a><a class="post-tag-link" href="/tags/proxy/">proxy</a><a class="post-tag-link" href="/tags/quinn/">quinn</a><a class="post-tag-link" href="/tags/rust/">rust</a><a class="post-tag-link" href="/tags/tokio/">tokio</a></div><div class="post-time">2020-08-06</div></div></div><div class="container post-header"><h1>使用rust写一个基于QUIC的proxy[0]</h1></div><div class="container post-content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><p>From wikipedia:</p>
<blockquote>
<p>QUIC (pronounced “quick”) is a general-purpose[1] transport layer[2] network protocol initially designed by Jim Roskind at Google,[3] implemented, and deployed in 2012,[4] announced publicly in 2013 as experimentation broadened,[5][6][7] and described to the IETF.[8] While still an Internet Draft, QUIC is used by more than half of all connections from the Chrome web browser to Google’s servers.[9] Microsoft Edge[10] and Firefox[11] support it, even if not enabled by default, as does Safari Technology Preview.[12]</p>
</blockquote>
<p>简单说，QUIC是一个基于UDP的可靠链接，协议定义需要tls，所以QUIC本身是可靠且安全的。因为是基于UDP，所以自然继承了UDP的所有优点。可以做到0RTT或0.5RTT。我看到国内的头条也有<a href="https://www.infoq.cn/article/OH79WEaK7Z3S2XaVO*BV" target="_blank" rel="noopener">QUIC的应用</a>了。B站的视频加载API已经是H3了！不清楚直播的上传API是不是基于QUIC或者H3，直播观看还是http1.1。</p>
<p>因为UDP是基于connection id的，所以当client从wifi切到4G是不会断网的。相对于TCP，QUIC最大的优点：彻底解决了<a href="https://http3-explained.haxx.se/en/why-quic/why-tcphol" target="_blank" rel="noopener">head of line blocking</a>。</p>
<p>QUIC也是google发起的，前身就是SPDY。有人说SPDY失败的原因在于过去几十年的硬件优化都是围绕TCP展开的，而SPDY的发展需要硬件厂商放弃过去的投资，重新投入。现在看来QUIC也有这方面的局限。据说UDP流量也会被QOS。在带宽有限的情况下，流量突然增大，TCP是网络提供商重点关注的，那自然UDP就是可以舍弃的。但是这都是YY，我没有实测。如果说打游戏算实测的话，那UDP国内情况还好吧，出口到国外估计会QOS。这也就是为什么有些代理会把UDP包成TCP再发。</p>
<p>另外一点，HTTP3就是基于QUIC的，这也算是个大背书吧？我看taobao的首页中，cdn资源99%都是H2的。但愿H3不会远吧。</p>
<h3 id="QUIC实现"><a href="#QUIC实现" class="headerlink" title="QUIC实现"></a>QUIC实现</h3><p>QUIC的实现还是挺多的。rust这边主要有三个实现：</p>
<ol>
<li><a href="https://github.com/cloudflare/quiche" target="_blank" rel="noopener">cloudflare quiche</a></li>
<li><a href="https://github.com/mozilla/neqo" target="_blank" rel="noopener">mozilla neqo</a></li>
<li><a href="https://github.com/djc/quinn" target="_blank" rel="noopener">quinn</a></li>
</ol>
<p>其中quiche在cloudflare生产环境跑起来了，neqo也算是生产级别吧。二者都很底层，quiche在tls这层用了google的<a href="https://boringssl.googlesource.com/boringssl/" target="_blank" rel="noopener">boringssl</a>，需要自己编译，这个东西我下载不下来。。。。neqo是自己实现的crypto。quinn使用rustls。印象中rustls的inbound和outbound session是不能并发访问的。看star的话，无疑quiche是rust首选。虽然quiche是一个实验型的项目，但是quinn实现到了tokio这层，所以写起来是最方便的，我还是决定先用quinn试试水。</p>
<h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>代理实现太多了，看了酸酸乳、V射线和某木马的源码，也没看懂…可怜的我c、c艹、go一个都不会。但是基本实现我还是看明白了的。</p>
<ol>
<li>代理的客户端负责接受请求，请求类型只能是UDP、TCP；</li>
<li>然后把接受的请求发送给代理服务器端，内容包括：需要代理的uri和整个request buf；</li>
<li>代理服务器端接受到uri和reqeust buf，需要与远端的uri建立链接，然后再把整个buf发送过去；</li>
<li>远端服务器把response发回给代理服务器；</li>
<li>代理服务器把接受到的response发回给代理客户端；</li>
<li>代理客户端把response发送给请求的调用方。</li>
</ol>
<p>如果代理的实现能让请求发送端看不出有代理的<strong>痕迹</strong>，那就是成功的透明代理了。这里会牵扯出一系列的问题，核心问题就是怎么维护连接。作为第一个版本，我就打算写个最简单的，以能跑起来为目的。客户端是一个http proxy + QUIC client，服务端是QUIC server + TcpStream。</p>
<h1 id="HTTP-Proxy"><a href="#HTTP-Proxy" class="headerlink" title="HTTP Proxy"></a>HTTP Proxy</h1><p>HTTP Proxy有一个特别的method：<strong>connect</strong></p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CONNECT</span> <span class="string">www.example.com:443</span> HTTP/1.1</span><br></pre></td></tr></table></figure>
<p>意味着，client请求代理打开一个proxy tunnel，代理回复OK，client会把真正的请求发送给代理。我在hyper的example里找到了一个<a href="https://github.com/hyperium/hyper/blob/3de81c822e6ac5a5b0640059f53838d0906f68c4/examples/http_proxy.rs" target="_blank" rel="noopener">HTTP Proxy例子</a>。只要把QUIC client的实现加上去，客户端就算写完了。</p>
<p>这个HTTP Proxy的实现重点有两个</p>
<h2 id="1-在接到connect之后创建一个tokio-task，并把与client的链接传进去，然后直接return-OK。"><a href="#1-在接到connect之后创建一个tokio-task，并把与client的链接传进去，然后直接return-OK。" class="headerlink" title="1. 在接到connect之后创建一个tokio task，并把与client的链接传进去，然后直接return OK。"></a>1. 在接到connect之后创建一个tokio task，并把与client的链接传进去，然后直接return OK。</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(addr) = host_addr(req.uri()) &#123;</span><br><span class="line">    tokio::task::spawn(<span class="keyword">async</span> <span class="keyword">move</span> &#123;</span><br><span class="line">        <span class="keyword">match</span> req.into_body().on_upgrade().<span class="keyword">await</span> &#123;</span><br><span class="line">            <span class="literal">Ok</span>(upgraded) =&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Err</span>(e) = tunnel(upgraded, addr).<span class="keyword">await</span> &#123;</span><br><span class="line">                    eprintln!(<span class="string">"server io error: &#123;&#125;"</span>, e);</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">Err</span>(e) =&gt; eprintln!(<span class="string">"upgrade error: &#123;&#125;"</span>, e),</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(Response::new(Body::empty()))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样连接是不会丢失的。具体的代理逻辑放到了异步task中执行，当前的请求response直接返回给客户。</p>
<h2 id="2-使用tokio-io-copy和try-join执行流量代理"><a href="#2-使用tokio-io-copy和try-join执行流量代理" class="headerlink" title="2. 使用tokio::io::copy和try_join执行流量代理"></a>2. 使用tokio::io::copy和try_join执行流量代理</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a TCP connection to host:port, build a tunnel between the connection and</span></span><br><span class="line"><span class="comment">// the upgraded connection</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">tunnel</span></span>(upgraded: Upgraded, addr: SocketAddr) -&gt; std::io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line">    <span class="comment">// Connect to remote server</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> server = TcpStream::connect(addr).<span class="keyword">await</span>?;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Proxying data</span></span><br><span class="line">    <span class="keyword">let</span> amounts = &#123;</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> server_rd, <span class="keyword">mut</span> server_wr) = server.split();</span><br><span class="line">        <span class="keyword">let</span> (<span class="keyword">mut</span> client_rd, <span class="keyword">mut</span> client_wr) = tokio::io::split(upgraded);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> client_to_server = tokio::io::copy(&amp;<span class="keyword">mut</span> client_rd, &amp;<span class="keyword">mut</span> server_wr);</span><br><span class="line">        <span class="keyword">let</span> server_to_client = tokio::io::copy(&amp;<span class="keyword">mut</span> server_rd, &amp;<span class="keyword">mut</span> client_wr);</span><br><span class="line"></span><br><span class="line">        try_join(client_to_server, server_to_client).<span class="keyword">await</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print message when done</span></span><br><span class="line">    <span class="keyword">match</span> amounts &#123;</span><br><span class="line">        <span class="literal">Ok</span>((from_client, from_server)) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(</span><br><span class="line">                <span class="string">"client wrote &#123;&#125; bytes and received &#123;&#125; bytes"</span>,</span><br><span class="line">                from_client, from_server</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Err</span>(e) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"tunnel error: &#123;&#125;"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tokio::io::copy在读到异常或读到0个字节会退出，也就是表示这次连接结束了。task return之后，两个连接连同tokio task一同被drop了。</p>
<p>我一开始以为copy这个方法会无限loop。其实是只读写一次的。所以每次请求都要开一个proxy tunnel。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>整个代理分别实现了client、server和protocol。没有特别复杂的东西，quinn用起来还挺简单的。唯一遇到的问题就是tokio::async_read_ext::read_buf这个方法与std的read逻辑不一样。tokio是根据传的buffer size来决定读多少。比如一个http的content response是同步的，我应该一次read就读完整个response。但是，如果使用tokio read，传入的buffer: </p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> buf: <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; = <span class="built_in">Vec</span>::with_capacity(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<p>那就只能读1024个字节。即便response是1025，那最后一个是读不到的。</p>
<p>随即我就想抄代码了。。。</p>
<p>开始翻越hyper的源码，想看看hyper是怎么实现读response的。然后就是一连串的惊呼…mum…</p>
<p>如果我没看漏，hyper从头到尾是没有直接调用read、write方法的。严格说，hyper从头到尾没有调用过async方法。hyper所有的处理逻辑都放在了poll里面。通过调用poll、实现自己的poll和状态机，方便了用户只在调用入口处使用<strong>await</strong>。非常简洁！看完hyper的源码，我算是入门future了。整个代码仓库基本没啥注释，看的我晕晕的。Hyper的作者看起来年纪也不大，rust在http这块的版图基本上都是这哥们贡献的。之前在mozilla，今年5月去了AWS。粉了粉了~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>史上最简单的基于QUIC的透明代理算是完工了。可以方便的代理http1请求，没试过http2。性能就不谈了，完全发挥不出rust的威力。</p>
<p>接下来会优化client和server管理连接的实现；以及，增加客户端代理类型：socks5。</p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>